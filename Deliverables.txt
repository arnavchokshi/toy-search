# Toy Search Engine Assignment

A simple Apache Lucene–based search engine with basic indexing and performance tests.

---

## (a) Source Code & Executable

* **Location:** All Java source files are under `src/main/java/com/yourname/toysearch/` and build settings in `pom.xml`.
* **Build:**

  ```bash
  mvn clean package
  ```
* **Run:** Use the Maven Exec plugin to launch each component:

  ```bash
  # Index 100 documents
  mvn exec:java -Dexec.mainClass=com.yourname.toysearch.IndexFiles

  # Add a single web document
  mvn exec:java \
    -Dexec.mainClass=com.yourname.toysearch.AddWebDoc \
    -Dexec.args="webdoc.txt squirrel"

  # Performance test (100, 200, 300 docs)
  mvn exec:java -Dexec.mainClass=com.yourname.toysearch.PerformanceTest
  ```

## (b) Crawler Design: Pros & Cons

* **Approach:** Uses `java.nio.file.Files.walk` to traverse a local `data/` directory of plain-text files.

* **Pros:**

  * Very simple to implement and debug.
  * No external dependencies; works offline.
  * Leverages Java’s fast I/O API for local file traversal.

* **Cons:**

  * Limited to local files—no HTTP fetching, robots.txt compliance, or rate limiting.
  * No support for parsing HTML or handling redirects.
  * Single-threaded; can be slow if I/O-bound on large directories.

* **Improvements:**

  * Integrate `java.net.http.HttpClient` + JSoup for web crawling.
  * Add a thread pool for parallel downloads and indexing.
  * Respect `robots.txt` and implement rate limiting on URLs.

## (c) Screenshots (in `screenshots/` folder)

1. `index100.png` – Console output showing indexing 100 documents and timing.
2. `addwebdoc.png` – Output after adding a new web document and searching for a keyword.
3. `perftest.png` – CSV-style performance results for K = 100, 200, 300.

*(Capture each screen at full terminal size and save these PNGs.)*

## (d) Index & Search Performance

| K (docs) | Time (s) |
| -------- | -------- |
| 100      | 0.097    |
| 200      | 0.026    |
| 300      | 0.024    |

*(Paste the exact numbers from your performance test run.)*

## (e) Example Index Entries

First five terms indexed from the `contents` field of your 100-doc sample:

```
1, 10, 100, 11, 12
```

*(These terms illustrate the inverted index contents.)*

## (f) Experience & Lessons Learned

f. Experience & Lessons Learned

Maven setup & dependencies

Created a Maven quickstart, added lucene-core, lucene-analysis-common, and lucene-queryparser.

Fixed a typo in the analyzers artifact name (lucene-analyzers-common → lucene-analysis-common).

HelloLucene in‐memory prototype

Learned the basic flow: Analyzer → IndexWriter → add Documents → IndexSearcher.

On‐disk indexing

Wrote IndexFiles using FSDirectory, walked a data/ folder of .txt files, timed the run, and handled empty‐index edge cases.

Maven Exec Plugin

Configured <exec-maven-plugin> so I could swap any mainClass without manual -cp gymnastics.

Incremental updates

Built AddWebDoc with OpenMode.APPEND, confirmed the new doc is indexed and searchable immediately.

Performance measurement

Created PerformanceTest to batch‐index K = 100, 200, 300 dummy docs, measured via System.nanoTime(), and exported CSV for easy tabulation.

Key takeaways:

Precise dependency names matter—Maven fails fast on typos.

JVM warm-up and disk/I-O caching can swamp microbenchmarks; always warm up and average multiple runs.

Automating with Maven Exec saves a ton of manual classpath work.

Real documents (multi-KB HTML/PDF) will index more slowly; dummy docs give an optimistic lower bound.

Next steps: integrate a simple HTTP crawler (JSoup + HttpClient), add parallel indexing, and benchmark query latencies.